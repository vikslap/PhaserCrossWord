<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Responsive Phaser Crossword</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      /* Page layout */
      body { margin:0; font-family:Inter,Arial,sans-serif; background:#071322; color:#e6eef6; }
      .wrap { display:flex; gap:14px; padding:16px; align-items:flex-start; flex-wrap:wrap; justify-content:center; }
      /* The game container will determine canvas size; keep padding around it */
      #game { background:linear-gradient(180deg,#06121a,#03202a); padding:12px; border-radius:8px; box-sizing:border-box; max-width:960px; width:100%; }
      /* Ensure the canvas fills the container */
      #game canvas { width:100% !important; height:auto !important; display:block; }
      /* UI column */
      #ui { width:360px; min-width:260px; max-width: 38%; box-sizing:border-box; }
      /* Small screens: make UI full width below the canvas */
      @media (max-width:920px) {
        .wrap { flex-direction:column; align-items:center; }
        #ui { width:92%; max-width:760px; }
      }

      /* Visual styles for clues and buttons (compact) */
      .panel { background:#071724; padding:12px; border-radius:8px; }
      ol { padding-left:18px; margin:8px 0; color:#9aa6b2; }
      li { margin:6px 0; cursor:pointer; }
      li.active { color:#fff; background:rgba(255,216,107,0.06); padding:4px; border-radius:4px; }
      .controls { display:flex; gap:8px; margin-top:10px; flex-wrap:wrap; }
      .controls button { background:#0b1320; border:1px solid rgba(255,255,255,0.04); color:#cbd5e1; padding:8px 10px; border-radius:6px; cursor:pointer; }
      .hint { margin-top:8px; color:#9aa6b2; font-size:13px; }
      .continue-btn { display:none; background:linear-gradient(90deg,#4ade80,#16a34a); color:#fff; border:none; padding:10px 20px; border-radius:8px; cursor:pointer; margin-top:12px; }
      .continue-btn.fade-in { animation: fadeInUp .28s ease forwards; }
      @keyframes fadeInUp { from{opacity:0; transform:translateY(6px)} to{opacity:1; transform:none;} }
    </style>
  </head>
  <body>
    <div class="wrap">
      <!-- Game container: its width controls the canvas width -->
      <div id="game" aria-label="crossword game container"></div>

      <div id="ui">
        <h2 style="margin:0 0 8px 0">Crossword</h2>
        <div class="panel">
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
            <div><strong>Across</strong><ol id="acrossList"></ol></div>
            <div><strong>Down</strong><ol id="downList"></ol></div>
          </div>

          <div class="controls">
            <button id="toggleDir">Toggle Dir (Space)</button>
          </div>

          <div id="msg" style="height:20px;margin-top:8px;color:#a6f0b3"></div>
          <div class="hint">Tap a cell, type letters (Aâ€“Z). Arrow keys move. Space toggles across/down. Words auto-validate when filled.</div>

          <button id="nextBtn" class="continue-btn" aria-hidden="true">Continue</button>
        </div>
      </div>
    </div>

    <!-- Phaser 3 -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>

    <script>
      /************************************************************************
       * Responsive crossword: responsive canvas + tile size computed from
       * container width. On resize/orientation change, the Phaser game is
       * recreated using the same saved progress (localStorage) so layout
       * adjusts for phones and desktops.
       *
       * Key idea:
       *  - The #game container width determines the canvas width.
       *  - tile = Math.floor((containerWidth - margin) / COLS)
       *  - When window size changes sufficiently, destroy & recreate game.
       ************************************************************************/

      /* ---------------------------
         Puzzle data (10x10 grid)
         --------------------------- */
      const solutionGrid = [
        "ENCRYPT###",
        "#####E####",
        "DDOS#N#F##",
        "##U##D#T##",
        "##DECRYPT#",
        "#####I##R#",
        "##D##V##O#",
        "#HACKER#J#",
        "##T#####A#",
        "##A#####N#"
      ];

      const acrossClues = {
        1: { r:0,c:0,len:7, clue:"Turn data into unreadable form.", answer:"ENCRYPT" },
        2: { r:2,c:0,len:4, clue:"Distributed network attack (abbr.).", answer:"DDOS" },
        3: { r:4,c:2,len:7, clue:"Opposite of encrypt.", answer:"DECRYPT" },
        4: { r:7,c:1,len:6, clue:"Someone who breaks into systems.", answer:"HACKER" },
      };

      const downClues = {
        5: { r:0,c:5,len:8, clue:"Portable USB storage (two words joined).", answer:"PENDRIVE" },
        6: { r:2,c:7,len:3, clue:"File Transfer Protocol.", answer:"FTP" },
        7: { r:4,c:8,len:6, clue:"Malware that hides in files (6).", answer:"TROJAN" },
      };

      const ROWS = 10, COLS = 10;
      const STORAGE_KEY = "image_crossword_fixed_v1";

      // Keep a reference to the Phaser Game instance so we can destroy/create
      let phaserGame = null;

      /************************************************************************
       * createGameForContainer
       * - computes canvas size from #game container
       * - computes tile size so grid fits horizontally
       * - creates a Phaser.Game with that width/height and passes tile size
       *   into the scene via global config (scene reads from window._CROSSWORD_CFG)
       ************************************************************************/
      function createGameForContainer() {
        // get the container and its current content width
        const container = document.getElementById("game");
        const rect = container.getBoundingClientRect();
        const containerWidth = Math.max(240, Math.floor(rect.width)); // minimum width guard

        // keep a small inner padding (12px each side) that matches CSS
        const innerPad = 12 * 2;
        // compute tile size so 10 columns fit with a small gap between tiles
        // leave some breathing room for strokes: tileRounded uses floor to avoid sub-pixel issues
        const tile = Math.floor((containerWidth - innerPad) / (COLS + 0.6)); // 0.6 is small extra spacing allowance
        const tileClamped = Math.max(28, Math.min(64, tile)); // clamp tile between 28 and 64 for readability

        // derive canvas dimensions: width fits columns, height allows rows + top/bottom margins
        const canvasWidth = Math.max(320, (tileClamped * COLS) + innerPad);
        const canvasHeight = tileClamped * ROWS + innerPad + 24; // extra space for aesthetics

        // store config for scene (so scene can compute baseX / tile)
        window._CROSSWORD_CFG = { tile: tileClamped, canvasWidth, canvasHeight };

        // if there's already a game, destroy it cleanly to rebuild
        if (phaserGame) {
          try { phaserGame.destroy(true); } catch (e) { /* ignore */ }
          phaserGame = null;
        }

        // Phaser config: use FIT/center for scaling and let the canvas pixel size be as computed
        const config = {
          type: Phaser.AUTO,
          parent: "game",
          width: canvasWidth,
          height: canvasHeight,
          backgroundColor: "#06121a",
          scene: [CrosswordScene],
          scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH }
        };

        phaserGame = new Phaser.Game(config);
      }

      /************************************************************************
       * Debounced resize handler
       * - Recreates the game only when container width changes by enough
       ************************************************************************/
      let _lastContainerWidth = 0;
      let _resizeTimer = null;
      function scheduleResize() {
        clearTimeout(_resizeTimer);
        _resizeTimer = setTimeout(() => {
          const w = document.getElementById("game").getBoundingClientRect().width;
          // only recreate if width changed by >= 8px to avoid thrash during tiny resizes
          if (Math.abs(w - _lastContainerWidth) >= 8) {
            _lastContainerWidth = w;
            createGameForContainer();
            populateLists(); // re-attach UI handlers (scene reference will be new)
          }
        }, 120);
      }

      /* Listen for window resize & orientation change */
      window.addEventListener("resize", scheduleResize);
      window.addEventListener("orientationchange", scheduleResize);

      /************************************************************************
       * Crossword Scene (reads tile and canvas size from window._CROSSWORD_CFG)
       ************************************************************************/
      class CrosswordScene extends Phaser.Scene {
        constructor() { super({ key: "CrosswordScene" }); }

        create() {
          // pull precomputed sizing config (tile, canvasWidth, canvasHeight)
          const cfg = window._CROSSWORD_CFG || {};
          const tile = cfg.tile || 48;
          const pad = Math.max(4, Math.round(tile * 0.125));
          this.tile = tile;
          this.pad = pad;

          // center the grid horizontally inside the canvas
          const canvasW = cfg.canvasWidth || this.game.config.width;
          const totalGridW = COLS * tile;
          // baseX is the left edge of the grid area (pad included)
          this.baseX = Math.max(12, Math.round((canvasW - totalGridW) / 2));
          this.baseY = 12; // top margin

          // load saved progress from localStorage (persisted by previous instances)
          this.progress = this.loadProgress();

          // cell storage: each cell contains {rect, text, isBlocked, solution, locked}
          this.cells = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
          this.selected = { r: 0, c: 0 };
          this.direction = "across";

          // create cells
          for (let r = 0; r < ROWS; r++) {
            const rowStr = solutionGrid[r] || "#".repeat(COLS);
            for (let c = 0; c < COLS; c++) {
              const x = this.baseX + c * tile + tile / 2;
              const y = this.baseY + r * tile + tile / 2;
              const ch = rowStr[c] || "#";
              const isBlocked = ch === "#";
              const bg = isBlocked ? 0x374151 : 0xffffff;
              const rect = this.add.rectangle(x, y, tile - pad, tile - pad, bg).setStrokeStyle(Math.max(1, Math.round(tile * 0.04)), 0x07121a);
              if (!isBlocked) rect.setInteractive(); // may be disabled later if gray-locked

              const txt = this.add.text(x, y, "", { font: `${Math.max(12, Math.round(tile * 0.42))}px monospace`, color: isBlocked ? "#0b1220" : "#000" }).setOrigin(0.5);

              // fill from saved progress if any
              const saved = (this.progress && this.progress[r] && this.progress[r][c]) ? this.progress[r][c] : "";
              if (saved && !isBlocked) txt.setText(saved);

              this.cells[r][c] = {
                rect,
                text: txt,
                isBlocked,
                solution: isBlocked ? null : rowStr[c] || "",
                locked: null
              };
            }
          }

          // gray-lock cells not covered by any clue
          this.markCellsNotInAnyClue();

          // attach pointer handlers only for interactive cells
          for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
              const cell = this.cells[r][c];
              if (!cell.isBlocked && cell.locked !== "gray-locked") {
                cell.rect.on("pointerdown", () => this.selectCell(r, c));
              } else {
                if (cell.rect.disableInteractive) cell.rect.disableInteractive();
              }
            }
          }

          // auto-select first interactive cell
          outer: for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
              if (!this.isCellBlocked(r, c)) { this.selectCell(r, c); break outer; }
            }
          }

          // keyboard handling (works on desktop; on mobile users use tap + software keyboard)
          this.input.keyboard.on("keydown", (evt) => {
            const k = evt.key;
            if (k === " ") { evt.preventDefault(); this.toggleDirection(); return; }
            if (/^[a-zA-Z]$/.test(k)) { this.putLetter(k.toUpperCase()); return; }
            if (k === "Backspace") { this.backspace(); return; }
            if (k.startsWith("Arrow")) this.moveSelection(k.replace("Arrow", "").toLowerCase());
          });

          // render the clue lists (UI lives outside Phaser)
          renderCluesUI();

          // check if saved progress already completes the puzzle
          this.checkPuzzleComplete();

          // expose scene for debugging from console if needed
          window.crosswordScene = this;
        }

        /* ---------- helpers & core logic (kept compact) ---------- */

        isCellBlocked(r, c) {
          const cell = this.cells[r] && this.cells[r][c];
          if (!cell) return true;
          return cell.isBlocked || cell.locked === "gray-locked";
        }

        // build coverage map from clues and gray-lock uncovered active cells
        markCellsNotInAnyClue() {
          const covered = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
          for (const id in acrossClues) {
            const cl = acrossClues[id];
            for (let i = 0; i < cl.len; i++) {
              const r = cl.r, c = cl.c + i;
              if (r >= 0 && r < ROWS && c >= 0 && c < COLS) covered[r][c] = true;
            }
          }
          for (const id in downClues) {
            const cl = downClues[id];
            for (let i = 0; i < cl.len; i++) {
              const r = cl.r + i, c = cl.c;
              if (r >= 0 && r < ROWS && c >= 0 && c < COLS) covered[r][c] = true;
            }
          }

          // persist reference
          const cur = this.loadProgress() || Array.from({ length: ROWS }, () => Array(COLS).fill(""));

          for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
              const cell = this.cells[r][c];
              if (!cell || cell.isBlocked) continue;
              if (!covered[r][c]) {
                cell.locked = "gray-locked";
                cell.rect.setFillStyle(0x374151); // gray
                cell.text.setText("");
                cur[r][c] = "";
              }
            }
          }
          try { localStorage.setItem(STORAGE_KEY, JSON.stringify(cur)); } catch (e) { /* ignore */ }
        }

        selectCell(r, c) {
          if (this.isCellBlocked(r, c)) return;
          this.selected = { r, c };
          this.highlightActiveWord();
          this.updateClueHighlight();
        }

        getActiveWordCells() {
          const { r, c } = this.selected;
          const out = [];
          if (this.direction === "across") {
            let sc = c; while (sc > 0 && !this.isCellBlocked(r, sc - 1)) sc--;
            let ec = c; while (ec < COLS && !this.isCellBlocked(r, ec)) ec++;
            for (let cc = sc; cc < ec; cc++) out.push({ r, c: cc, cell: this.cells[r][cc] });
          } else {
            let sr = r; while (sr > 0 && !this.isCellBlocked(sr - 1, c)) sr--;
            let er = r; while (er < ROWS && !this.isCellBlocked(er, c)) er++;
            for (let rr = sr; rr < er; rr++) out.push({ r: rr, c, cell: this.cells[rr][c] });
          }
          return out;
        }

        highlightActiveWord() {
          this.clearHighlights();
          const cells = this.getActiveWordCells();
          cells.forEach(({ r, c }) => {
            if (this.cells[r][c].locked === null) this.cells[r][c].rect.setFillStyle(0xe8f3ff);
          });
          const s = this.selected;
          if (!this.isCellBlocked(s.r, s.c) && this.cells[s.r][s.c].locked === null) {
            this.cells[s.r][s.c].rect.setFillStyle(0xfffbcc);
          }
        }

        clearHighlights() {
          for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
              const cell = this.cells[r][c];
              if (!cell) continue;
              if (cell.isBlocked || cell.locked === "gray-locked") cell.rect.setFillStyle(0x374151);
              else if (cell.locked === "correct") cell.rect.setFillStyle(0xccffcc);
              else if (cell.locked === "wrong") cell.rect.setFillStyle(0xffcccc);
              else cell.rect.setFillStyle(0xffffff);
            }
          }
        }

        updateClueHighlight() {
          document.querySelectorAll("#acrossList li, #downList li").forEach(li => li.classList && li.classList.remove("active"));
          const cells = this.getActiveWordCells(); if (!cells.length) return;
          const start = cells[0];
          if (this.direction === "across") {
            for (const id in acrossClues) {
              const cl = acrossClues[id];
              if (cl.r === start.r && cl.c === start.c && cl.len === cells.length) {
                const el = document.querySelector(`#acrossList li[data-id="${id}"]`);
                if (el) el.classList.add("active");
                break;
              }
            }
          } else {
            for (const id in downClues) {
              const cl = downClues[id];
              if (cl.r === start.r && cl.c === start.c && cl.len === cells.length) {
                const el = document.querySelector(`#downList li[data-id="${id}"]`);
                if (el) el.classList.add("active");
                break;
              }
            }
          }
        }

        toggleDirection() { this.direction = this.direction === "across" ? "down" : "across"; this.highlightActiveWord(); this.updateClueHighlight(); this.showMsg(`Direction: ${this.direction.toUpperCase()}`, 900); }

        putLetter(letter) {
          const { r, c } = this.selected;
          if (this.isCellBlocked(r, c)) return;
          const cell = this.cells[r][c];
          const wordCells = this.getActiveWordCells();
          this.clearLocksForCells(wordCells);
          cell.text.setText(letter);
          this.saveLetter(r, c, letter);
          if (this.direction === "across") { let nc = c + 1; while (nc < COLS && this.isCellBlocked(r, nc)) nc++; if (nc < COLS) this.selectCell(r, nc); }
          else { let nr = r + 1; while (nr < ROWS && this.isCellBlocked(nr, c)) nr++; if (nr < ROWS) this.selectCell(nr, c); }
        }

        backspace() {
          const { r, c } = this.selected;
          if (this.isCellBlocked(r, c)) return;
          const cell = this.cells[r][c];
          const wordCells = this.getActiveWordCells();
          this.clearLocksForCells(wordCells);
          if (cell.text.text) { cell.text.setText(""); this.saveLetter(r, c, ""); }
          else {
            if (this.direction === "across") { let nc = c - 1; while (nc >= 0 && this.isCellBlocked(r, nc)) nc--; if (nc >= 0) this.selectCell(r, nc); }
            else { let nr = r - 1; while (nr >= 0 && this.isCellBlocked(nr, c)) nr--; if (nr >= 0) this.selectCell(nr, c); }
          }
        }

        clearLocksForCells(cells) {
          cells.forEach(({ r, c }) => {
            if (this.cells[r][c].locked !== null && this.cells[r][c].locked !== "gray-locked") {
              this.cells[r][c].locked = null;
              this.cells[r][c].rect.setFillStyle(0xffffff);
            }
          });
        }

        checkActiveWordOnCompletion() {
          const cells = this.getActiveWordCells();
          if (!cells.length) return;
          let entered = "", allFilled = true;
          cells.forEach(({ r, c }) => { const ch = (this.cells[r][c].text.text || "").trim(); entered += ch; if (!ch) allFilled = false; });
          if (!allFilled) { this.clearLocksForCells(cells); this.highlightActiveWord(); return; }
          const start = cells[0];
          let clue = null;
          if (this.direction === "across") clue = Object.values(acrossClues).find(cl => cl.r === start.r && cl.c === start.c && cl.len === cells.length);
          else clue = Object.values(downClues).find(cl => cl.r === start.r && cl.c === start.c && cl.len === cells.length);
          if (!clue) return;
          if (entered.toUpperCase() === clue.answer.toUpperCase()) cells.forEach(({ r, c }) => { this.cells[r][c].locked = "correct"; this.cells[r][c].rect.setFillStyle(0xccffcc); });
          else cells.forEach(({ r, c }) => { this.cells[r][c].locked = "wrong"; this.cells[r][c].rect.setFillStyle(0xffcccc); });
          this.checkPuzzleComplete();
        }

        finalizeCompletedPuzzle() {
          const cur = this.loadProgress() || Array.from({ length: ROWS }, () => Array(COLS).fill(""));
          for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
              const cell = this.cells[r][c];
              if (!cell || cell.isBlocked) continue;
              const current = (cell.text.text || "").trim();
              if (!current) { cell.locked = "gray-locked"; cell.rect.setFillStyle(0x374151); cur[r][c] = ""; if (cell.rect.disableInteractive) cell.rect.disableInteractive(); }
              else { cell.locked = "correct"; cell.rect.setFillStyle(0xccffcc); cur[r][c] = current; }
            }
          }
          try { localStorage.setItem(STORAGE_KEY, JSON.stringify(cur)); } catch (e) { /* ignore */ }
        }

        checkPuzzleComplete() {
          let allOk = true;
          for (const id in acrossClues) {
            const cl = acrossClues[id];
            let entered = "";
            for (let i = 0; i < cl.len; i++) { const r = cl.r, c = cl.c + i; entered += (this.cells[r][c].text.text || ""); }
            if (entered.toUpperCase() !== cl.answer.toUpperCase()) { allOk = false; break; }
          }
          if (allOk) for (const id in downClues) {
            const cl = downClues[id];
            let entered = "";
            for (let i = 0; i < cl.len; i++) { const r = cl.r + i, c = cl.c; entered += (this.cells[r][c].text.text || ""); }
            if (entered.toUpperCase() !== cl.answer.toUpperCase()) { allOk = false; break; }
          }
          crosswordSolved = allOk;
          const nextBtn = document.getElementById("nextBtn");
          if (nextBtn) {
            if (crosswordSolved) { this.finalizeCompletedPuzzle(); nextBtn.style.display = "inline-block"; nextBtn.classList.add("fade-in"); nextBtn.setAttribute("aria-hidden", "false"); }
            else { nextBtn.classList.remove("fade-in"); nextBtn.setAttribute("aria-hidden", "true"); nextBtn.style.display = "none"; }
          }
          return allOk;
        }

        showMsg(text, ms = 1400) { const el = document.getElementById("msg"); el.textContent = text; setTimeout(() => { if (el.textContent === text) el.textContent = ""; }, ms); }

        saveLetter(r, c, ch) {
          const cur = this.loadProgress() || Array.from({ length: ROWS }, () => Array(COLS).fill(""));
          cur[r][c] = ch;
          try { localStorage.setItem(STORAGE_KEY, JSON.stringify(cur)); } catch (e) { /* ignore */ }
          this.checkActiveWordOnCompletion();
        }

        loadProgress() {
          try { const raw = localStorage.getItem(STORAGE_KEY); if (!raw) return null; return JSON.parse(raw); } catch (e) { return null; }
        }
      } // end scene

      /************************************************************************
       * UI helpers outside Phaser
       ************************************************************************/
      function renderCluesUI() {
        const aList = document.getElementById("acrossList"), dList = document.getElementById("downList");
        aList.innerHTML = ""; dList.innerHTML = "";
        Object.keys(acrossClues).sort((a,b)=>a-b).forEach(id => {
          const cl = acrossClues[id];
          const li = document.createElement("li");
          li.dataset.id = id;
          li.textContent = `${id}. ${cl.clue} (${cl.len})`;
          li.addEventListener("click", () => { if (window.crosswordScene) { window.crosswordScene.direction = "across"; window.crosswordScene.selectCell(cl.r, cl.c); } });
          aList.appendChild(li);
        });
        Object.keys(downClues).sort((a,b)=>a-b).forEach(id => {
          const cl = downClues[id];
          const li = document.createElement("li");
          li.dataset.id = id;
          li.textContent = `${id}. ${cl.clue} (${cl.len})`;
          li.addEventListener("click", () => { if (window.crosswordScene) { window.crosswordScene.direction = "down"; window.crosswordScene.selectCell(cl.r, cl.c); } });
          dList.appendChild(li);
        });
      }

      /* -------------------------
         Boot: create responsive game & wire minimal UI
         ------------------------- */
      // initial create
      createGameForContainer();
      _lastContainerWidth = document.getElementById("game").getBoundingClientRect().width;

      // wire UI controls after initial creation
      window.addEventListener("load", () => {
        document.getElementById("toggleDir").addEventListener("click", () => { if (window.crosswordScene) window.crosswordScene.toggleDirection(); });
        const nextBtn = document.getElementById("nextBtn");
        if (nextBtn) nextBtn.addEventListener("click", () => { alert("Puzzle solved! Continue..."); });
        renderCluesUI();
      });

      // also schedule a resize when the page becomes visible (useful on device rotate)
      window.addEventListener("visibilitychange", () => { if (document.visibilityState === "visible") scheduleResize(); });
    </script>
  </body>
</html>
